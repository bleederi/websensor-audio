<!--
Websensor audio project
https://github.com/jessenie-intel/websensor-video

Copyright (c) 2017 Jesse Nieminen

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Code based on tutorial from http://www.emanueleferonato.com/2014/12/10/html5-webgl-360-degrees-panorama-viewer-with-three-js/
-->
<!doctype html>
<html>
	<head>
                <meta charset="UTF-8" />
                <meta name="viewport" content="width=device-width, initial-scale=0.6">
                <link rel="manifest" href="manifest.json" />
		<style>
			body{
				margin: 0;
			}
			canvas{
				width: 100%;
				height: 100%
			}
		</style>
		<script src="three.min.js"></script>
		
	</head>
        <template id="sphere-view">
                <style>
                :host {
                width: 100vh;
                height: 100vh;
                }
                canvas {
                margin: 16px;
                }
                </style>
        </template>
	<body>
		<script>
                        

                        /*
                        *       Sensor related code below
                        */
                        function toEulerianAngle(quat, out)
                        {
                                const ysqr = quat[1] ** 2;
               
                                // Roll (x-axis rotation).
                                const t0 = 2 * (quat[3] * quat[0] + quat[1] * quat[2]);
                                const t1 = 1 - 2 * (ysqr + quat[0] ** 2);
                                out[0] = Math.atan2(t0, t1);
                                // Pitch (y-axis rotation).
                                let t2 = 2 * (quat[3] * quat[1] - quat[2] * quat[0]);
                                t2 = t2 > 1 ? 1 : t2;
                                t2 = t2 < -1 ? -1 : t2;
                                out[1] = Math.asin(t2);
                                // Yaw (z-axis rotation).
                                const t3 = 2 * (quat[3] * quat[2] + quat[0] * quat[1]);
                                const t4 = 1 - 2 * (ysqr + quat[2] ** 2);
                                out[2] = Math.atan2(t3, t4);
                                return out;
                        }
                        class InclinationSensor {
                                constructor() {
                                const sensor = new AbsoluteOrientationSensor({ frequency: 60 });
                                const mat4 = new Float32Array(16);
                                const euler = new Float32Array(3);
                                sensor.onreading = () => {
                                        sensor.populateMatrix(mat4);
                                        let angles = toEulerianAngle(sensor.quaternion, euler);
                                        this.roll = euler[0];
                                        this.pitch = euler[1];
                                        this.yaw = euler[2];
                                        if (this.onreading) this.onreading();
                                };
                                sensor.onactivate = () => {
                                        if (this.onactivate) this.onactivate();
                                }
                                const start = () => sensor.start();
                                Object.assign(this, { start });
                                }
                        }
                        customElements.define('sphere-view', class extends HTMLElement {
                        constructor() {
                        super();
                        const template = document.querySelector('#sphere-view');
                        const clone = document.importNode(template.content, true);
                        const shadowRoot = this.attachShadow({ mode: 'open' });
                        shadowRoot.appendChild(clone);
                        }
                        connectedCallback() {
			this.init();
			this.render();
                        this.latitude;
                        this.longitude;
			var container;
			var camera, controls, scene, renderer;
			var light, pointLight;

			var material1, material2, material3;

			var analyser1, analyser2, analyser3;

			var clock = new THREE.Clock();


}
                init() {
				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 0, 25, 0 );

				var listener = new THREE.AudioListener();
				camera.add( listener );

				scene = new THREE.Scene();
				scene.fog = new THREE.FogExp2( 0x000000, 0.0025 );

				light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 0, 0.5, 1 ).normalize();
				scene.add( light );

				var sphere = new THREE.SphereGeometry( 20, 32, 16 );

				material1 = new THREE.MeshPhongMaterial( { color: 0xffaa00, shading: THREE.FlatShading, shininess: 0 } );
				material2 = new THREE.MeshPhongMaterial( { color: 0xff2200, shading: THREE.FlatShading, shininess: 0 } );
				material3 = new THREE.MeshPhongMaterial( { color: 0x6622aa, shading: THREE.FlatShading, shininess: 0 } );

				// sound spheres

				var audioLoader = new THREE.AudioLoader();

				var mesh1 = new THREE.Mesh( sphere, material1 );
				mesh1.position.set( -250, 30, 0 );
				scene.add( mesh1 );

				var sound1 = new THREE.PositionalAudio( listener );
				audioLoader.load( 'sounds/baby-music-box_daniel-simion.wav', function( buffer ) {
					sound1.setBuffer( buffer );
					sound1.setRefDistance( 20 );
					sound1.play();
				});
				mesh1.add( sound1 );
                        /*
                        *       Audio code below
                        */	

                        /*
                        *       Sensor initialization below
                        */
                        const sensor = new InclinationSensor();
                        sensor.onreading = () => {
                        this.roll = sensor.roll;
                        this.pitch = sensor.pitch;
                        this.yaw = sensor.yaw;
                        }
                        sensor.onactivate = () => {};
                        sensor.start();
                        }

                        render() {
				var delta = clock.getDelta();

				controls.update( delta );

				material1.emissive.b = analyser1.getAverageFrequency() / 256;
				material2.emissive.b = analyser2.getAverageFrequency() / 256;
				material3.emissive.b = analyser3.getAverageFrequency() / 256;

				renderer.render( scene, camera );
                        }
                        });
		</script>

                <sphere-view></sphere-view>
	</body>
</html>

